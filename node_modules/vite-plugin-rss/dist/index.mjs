var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/plugin.ts
import stream from "stream";
import convert from "xml-js";

// src/type-guards.ts
function isJsXmlElement(value) {
  return typeof value === "object" && value !== null && "_attribute" in value && "_text" in value;
}
function isImage(value) {
  return typeof value === "object" && value !== null && "url" in value && "title" in value && "link" in value;
}
function isTextInput(value) {
  return typeof value === "object" && value !== null && "title" in value && "description" in value && "name" in value && "name" in value && "link" in value;
}
function isSkipHours(value) {
  return typeof value === "object" && value !== null && "hour" in value && Array.isArray(value["hour"]);
}
function isSkipDays(value) {
  return typeof value === "object" && value !== null && "day" in value && Array.isArray(value["day"]);
}

// src/plugin.ts
function rssPlugin(opts) {
  return [devPlugin(opts), buildPlugin(opts)];
}
function devPlugin(opts) {
  let items = getItems(opts);
  const fileName = getFileName(opts);
  return {
    name: "rss-plugin-dev",
    enforce: "post",
    apply: "serve",
    configureServer(server) {
      server.middlewares.use((req, res, next) => {
        if (typeof req.url === "string" && new RegExp(`${fileName}$`).test(req.url)) {
          if (opts.mode === "meta") {
            const devServerModuleIds = Array.from(server.moduleGraph.idToModuleMap.keys());
            const moduleInfo = devServerModuleIds.map((id) => server.pluginContainer.getModuleInfo(id));
            items = moduleInfo.filter((module) => !!(module == null ? void 0 : module.meta.rssItem)).map((module) => module.meta.rssItem);
          }
          const renderedXML = createRssFeed(opts.channel, items != null ? items : [], fileName);
          const fileContent = Buffer.from(renderedXML, "utf8");
          const readStream = new stream.PassThrough();
          readStream.end(fileContent);
          res.writeHead(200, {
            "Content-Type": "text/xml"
          });
          readStream.pipe(res);
          return;
        }
        next();
      });
    }
  };
}
function buildPlugin(opts) {
  let items = getItems(opts);
  const fileName = getFileName(opts);
  return {
    name: "rss-plugin-build",
    enforce: "post",
    apply: "build",
    buildEnd() {
      if (opts.mode === "meta") {
        const moduleIds = Array.from(this.getModuleIds());
        const moduleInfo = moduleIds.map((id) => this.getModuleInfo(id));
        items = moduleInfo.filter((module) => !!(module == null ? void 0 : module.meta.rssItem)).map((module) => module.meta.rssItem);
      }
      const renderedXML = createRssFeed(opts.channel, items, fileName);
      this.emitFile({
        fileName,
        name: fileName,
        source: renderedXML,
        type: "asset"
      });
    }
  };
}
function getFileName(opts) {
  var _a;
  return (_a = opts.fileName) != null ? _a : "feed.xml";
}
function getItems(opts) {
  if (opts.mode === "define")
    return opts.items;
  return [];
}
function createRssFeed(channel, items, fileName) {
  const dateSortedRssItems = items.sort((a, b) => {
    if (a.pubDate && b.pubDate) {
      return b.pubDate.getTime() - a.pubDate.getTime();
    }
    if (a.pubDate) {
      return 1;
    }
    if (b.pubDate) {
      return -1;
    }
    return 0;
  });
  const jsXml = {
    _declaration: { _attributes: { version: "1.0", encoding: "utf-8" } },
    rss: {
      _attributes: {
        version: "2.0",
        "xmlns:atom": "http://www.w3.org/2005/Atom"
      },
      channel: __spreadProps(__spreadValues({}, channelToXmlJs(channel, fileName)), {
        item: dateSortedRssItems.map((r) => itemToXmlJs(r)).slice(0, 100)
      })
    }
  };
  return convert.js2xml(jsXml, { compact: true, spaces: 2 });
}
function channelToXmlJs(channel, fileName) {
  const jsXml = {};
  Object.keys(channel).forEach((tagName) => {
    const value = channel[tagName];
    if (typeof value === "string" || typeof value === "number") {
      jsXml[tagName] = {
        _text: value
      };
    } else if (value instanceof Date) {
      jsXml[tagName] = {
        _text: value.toUTCString()
      };
    } else if (isJsXmlElement(value)) {
      jsXml[tagName] = value;
    } else if (isImage(value) || isTextInput(value)) {
      jsXml[tagName] = __spreadValues({}, value);
    } else if (isSkipDays(value)) {
      jsXml[tagName] = {
        day: value.day.map((d) => ({ _text: d }))
      };
    } else if (isSkipHours(value)) {
      jsXml[tagName] = {
        hour: value.hour.map((d) => ({ _text: d }))
      };
    } else if (tagName === "docs" && value) {
      jsXml[tagName] = {
        _text: "https://www.rssboard.org/rss-specification"
      };
    } else if (tagName === "generator" && value) {
      jsXml[tagName] = {
        _text: "vite-plugin-rss"
      };
    }
  });
  const url = new URL(channel.link);
  jsXml["atom:link"] = {
    _attributes: {
      href: `${url.origin}/${fileName}`,
      rel: "self",
      type: "application/rss+xml"
    }
  };
  return jsXml;
}
function itemToXmlJs(item) {
  const jsXml = {};
  Object.keys(item).forEach((tagName) => {
    const value = item[tagName];
    if (typeof value === "string" || typeof value === "number") {
      jsXml[tagName] = {
        _text: value
      };
    } else if (value instanceof Date) {
      jsXml[tagName] = {
        _text: value.toUTCString()
      };
    } else if (isJsXmlElement(value)) {
      jsXml[tagName] = value;
    }
  });
  return jsXml;
}
export {
  isImage,
  isJsXmlElement,
  isSkipDays,
  isSkipHours,
  isTextInput,
  rssPlugin
};
//# sourceMappingURL=index.mjs.map